#!/usr/bin/perl
# SPDX-License-Identifier: BSD-2-Clause
#
# $ mkdokkrfile.pl $
#
# Author: Tomi Ollila -- too Ã¤t iki piste fi
#
#	Copyright (c) 2018 Tomi Ollila
#	    All rights reserved
#
# Created: Thu 24 May 2018 21:22:12 EEST too
# Last modified: Mon 28 May 2018 22:41:57 +0300 too

use 5.10.1;
use strict;
use warnings;

$ENV{'PATH'} = '/sbin:/usr/sbin:/bin:/usr/bin';

my %gvars = ( spc => ' ', tab => "\t", nl => "\n" );
my $c = 0;
foreach  (@ARGV) {
    last unless /([\w-]+)=(.*)/;
    $gvars{$1} = $2;
    $c++;
}
splice @ARGV, 0, $c if $c;

#while (my ($k, $v) = each %gvars) { print "%gvars: $k, '$v'\n"; }; print "\n";

die "\nUsage: $0 [var=val [var2=val2...]] file.src [file2.src...]\n\n"
    unless @ARGV;

# just some checks against accidents. same not done for ....include's
$c = 0;
foreach (@ARGV) {
    $c++, warn ("'$_': does not end with '.src'\n"), next unless /[.]src$/;
    $c++, warn ("'$_': no such file\n"), next unless -f $_;
    $c++, warn ("'$_': unreadable\n"), next unless -r $_;
    $c++, warn ("'$_': empty\n"), next unless -s $_;
}
exit 1 if $c;

my $addcksum;
if (eval 'use Digest::MD5 qw/md5_hex/; 1') {
    $addcksum = sub { print "## md5: ", md5_hex($_[0]), "\n"; };
} else { $addcksum = 0; }

my %vars;
my $ple;
sub dfio($$$); # prototype for self-recursing function
sub dfio($$$)
{
    my ($fh, $fn) = ($_[0], $_[1]);
    my $ln = 1;
    print qq'$_[2] 2 "$fn"\n';
    $_ = <$fh>;
    die "No readable content in $fn\n" unless $_;
    chomp, die "$fn line 1 is not '....mkdokkrfile 1.0'",
	" (is '$_')\n" unless /^\.{4}mkdokkrfile\s+1.0\s/;
    my $skip = 0;
    my $run_skipline_prefix = qr/^\s*#\s/;
    my $varsubs = sub {
	1 while $_[0] =~ s/<\.\.([\w-]+)\.\.>/$vars{$1} or
	    die "$fn line $ln: '$1' not defined\n"/ge;
    };
    while (<$fh>)
    {
	last if /^\s*__END__\s*$/;
	$ln++;
	$skip = 1, next if /^\s*__SKIP__\s/;
	$skip = 0, next if /^\s*__CONT__\s/;
	next if $skip;
	if (/^\.{4}set\s+([\w-]+)\s+(.*)/) {
	    my ($var, $val) = ($1, $2);
	    $varsubs->($val);
	    $vars{$var} = $val;
	    next;
	}
	$varsubs->($_); #warn $_;

	if (/^\.{4}include\s+(\S+)/) {
	    my $fni = $1;
	    die "$fn line $ln: Nesting too deep: $_" if length $_[2] > 10;
	    open my $fhi, '<', $fni or
		die "$fn line $ln: Cannot open $fni: $!\n";
	    dfio $fhi, $fni, $_[2] . '#';
	    my $pln = $ln + 1;
	    print qq'$_[2] $pln "$_[1]"\n';
	    next;
	}
	if (/^\.{4}run-skipline-prefix\s+(.*)/) {
	    if ($1 eq '') { $run_skipline_prefix = '' }
	    else { $run_skipline_prefix = qr/^\s*$1\s/ }
	    next;
	}
	if (/^\s*$/) {
	    $ple = 1, print $_ unless $ple;
	    next;
	}
	$ple = 0 if $ple;

	if (/^\.{4}run\s+(.*)/) {
	    my @content = ( 'RUN ["');
	    push @content, "$_\", \"" foreach (split ' ', $1);
	    push @content, "\\\n";
	    my @lines;
	    my $rl = $ln;
	    while (<$fh>) {
		$ln++;
		$rl = 0, last if /^[.]{4}end\s*$/;
		push @lines, $_;
	    }
	    # drop one empty line from beginning and end of a run block
	    # add extra empty line(s) if such space is desired...
	    pop @lines if $lines[$#lines] =~ /^\s*$/;
	    shift @lines if @lines && $lines[0] =~ /^\s*$/;
	    foreach (@lines) {
		next if $run_skipline_prefix and /$run_skipline_prefix/;
		$varsubs->($_); s/\\/\\\\/g; s/"/\\"/g; s/\t/\\t/g; s/$/\\n\\/;
		s/^\s*\K#/\\u0023/; # yeah, right...
		push @content, $_;
	    }
	    push @content, "\"]\n";
	    print @content;
	    die "$fn line $ln: no '....end' (for ....run at line $rl)\n"
		if $rl;
	    $addcksum->( join '', @content ) if $addcksum;
	    print "\n"; $ple = 1;
	    next;
	}
	die "Unknown line $fn:$ln: $_" if /^\.\./;
	print $_;
    }
}

my $bn0 = $0; $bn0 =~ s,.*/,,;
foreach (@ARGV) {
    my $fn = $_;
    s/[.]src$// or die; # internal error
    my $bn = $_;

    open my $fh, '<', $fn or die "Cannot open $fn: $!\n";
    open O, '>', "$bn.wip" or die "Cannot open $bn.wip: $!\n";

    select O;
    print "# Generated by $bn0\n";
    %vars = %gvars;
    $ple = 0;
    dfio $fh, $fn, '#';
    close O or die $!;
    close $fh or die $!;
    select STDOUT;
    if ( -f "$bn.out" ) {
	open P, '-|', qw/diff -u/, "$bn.out", "$bn.wip";
	my $o = <P>;
	my $n = <P>;
	if (defined $n) {
	    open O, '>>', 'dokkrfile.diffs';
	    $o =~ s/[.]out(\s)/.prv$1/;
	    $n =~ s/[.]wip(\s)/.out$1/;
	    print O "\n$o$n";
	    print O $_ while (<P>);
	    print O "\n";
	    close O;
	}
	close P;
    }
    rename "$bn.wip", "$bn.out"
	or die "Cannot rename $bn.wip to $bn.out: $!\n";
}
